#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass amsbook
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part
Base
\end_layout

\begin_layout Chapter
基础
\end_layout

\begin_layout Section
数据结构
\end_layout

\begin_layout Standard
背包(Bag)
\end_layout

\begin_layout Standard
队列(Queue | FIFO)先进先出
\end_layout

\begin_layout Standard
栈(下压栈)(Stack | LIFO) 后进先出 .
 
\end_layout

\begin_layout Standard
双栈算术表达式求值算法
\end_layout

\begin_layout Enumerate
将操作数压入操作数栈； 
\end_layout

\begin_layout Enumerate
将运算符压入运算符栈；
\end_layout

\begin_layout Enumerate
忽略左括号； 
\end_layout

\begin_layout Enumerate
在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈.
 
\end_layout

\begin_layout Standard
链表
\end_layout

\begin_layout Section
算法分析
\end_layout

\begin_layout Standard
一个程序运行的总时间主要和两点有关: 
\end_layout

\begin_layout Standard
执行每条语句的耗时；
\end_layout

\begin_layout Standard
执行每条语句的频率.
 
\end_layout

\begin_layout Standard

\series bold
算法分析中常用的近似函数:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
描述
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
近似函数
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
调和级数求和
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
等差数列求和
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
等比数列求和
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
斯特灵公式
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
二项式系数
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
指数函数
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
增长数量级的常见假设的总结:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
描述
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
增长的数量级
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
典型的代码
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
说明
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
举例
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
常数级别
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a = b + c;
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
普通语句
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
将两个数相加
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
对数级别
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
对数级别
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
二分策略
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
二分查找
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
线性级别
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
循环
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
找出最大元素
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
线性对数级别
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N\log N$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
分治
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
归并排序
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
平方级别
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
双层循环
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
检查所有元素对
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
立方级别
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N^{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
三层循环
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
检查所有三元组
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
指数级别
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{N}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
穷举查找
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
检查所有子集
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Chapter
排序
\end_layout

\begin_layout Section
冒泡排序(Bubble Sort)
\end_layout

\begin_layout Standard
一次比较两个元素，如果它们的顺序错误就把它们交换过来
\end_layout

\begin_layout Section
选择排序(Selection Sort)
\end_layout

\begin_layout Standard
找到数组中
\series bold
最小
\series default
的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换.
 ).
 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置.
 如此往复，直到将整个数组排序.
 (第一小到第一个位置, 第二小到第二个位置)
\end_layout

\begin_layout Standard
分析: 对于长度为
\begin_inset Formula $N$
\end_inset

的数组:
\end_layout

\begin_layout Standard
交换的总次数是
\begin_inset Formula $N$
\end_inset


\end_layout

\begin_layout Standard
比较的次数: 
\begin_inset Formula $(N-1)+(N-2)\cdots+2+1=\frac{N^{2}}{2}$
\end_inset


\end_layout

\begin_layout Section
插入排序(Insertion Sort)
\end_layout

\begin_layout Standard
取一个数, 恰当的放入已经有序的数据中.
\end_layout

\begin_layout Standard
插入排序有两个循环.
 外循环将数组元素挨个移动,而内循环则对外循环中选中的元素及它后面的那个元素进行比较.
 如果外循环中选中的元素比内循环中选中的元素小,那么数组元素会向右移动,为内循环中的这个元素腾出位置.
\end_layout

\begin_layout Standard
分析: 对于长度为
\begin_inset Formula $N$
\end_inset

的数组:
\end_layout

\begin_layout Standard
移动次数: 最好情况不需要移动, 最坏的情况所有元素都需要移动, 移动次数是
\begin_inset Formula $\frac{N^{2}}{2}$
\end_inset

, 在平均情况下每个元素都可能向后移动半个数组的长度,移动次数是
\begin_inset Formula $\frac{N^{2}}{4}$
\end_inset

.
\end_layout

\begin_layout Standard
比较次数: 比较的总次数是交换的次数加上一个额外的项，该项为 减去被插入的元素正好是已知的最小元素的次数.
 在最坏情况下(逆序数组)，这一项相对于总数可以忽略不计；在最好情况下(数组已经有序)，这一项等于
\begin_inset Formula $N-1$
\end_inset

 .
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/插入排序的轨迹.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
插入排序的轨迹
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
部分有序的数组: 
\end_layout

\begin_layout Itemize
数组中每个元素距离它的最终位置都不远； 
\end_layout

\begin_layout Itemize
一个有序的大数组接一个小数组； 
\end_layout

\begin_layout Itemize
数组中只有几个元素的位置不正确.
 
\end_layout

\begin_layout Standard
链表,向右移动
\end_layout

\begin_layout Section
希尔排序(Shell Sort)
\end_layout

\begin_layout Standard
插入排序升级版(我感觉是冒泡排序的升级版), 一个 h 有序数组就是 h 个互相独立的有序数组
\series bold
编织
\series default
在一起组成的一个数组.
 
\end_layout

\begin_layout Standard
希尔排序的核心理念与插入排序不同，它会首先比较 
\series bold
距离较远
\series default
的元素，而非相邻的元素.
 和简单地比较相邻元素相比，使用这种方案可以使离正确位置很远的元素更快地回到合适的位置.
 当开始用这个算法遍历数据集时，所有元素之间的距离会不断减小，直到处理到数据集的末尾，这时算法比较的就是相邻元素了.
 
\end_layout

\begin_layout Standard
通过定义一个间隔序列来表示在排序过程中进行比较的元素之间有多远的间隔.
\end_layout

\begin_layout Standard
算法的性能不仅取决于 h，还取决于 h 之间的数学性质.
\end_layout

\begin_layout Standard
适用大数组.
\end_layout

\begin_layout Fact
使用递增序列 1, 4, 13, 40, 121, 364… 的希尔排序所需的比较次数不会超出N的若干倍乘以递增序列的长度.
 
\end_layout

\begin_layout Fact
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/ShellSort.png
	lyxscale 50
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
ShellSort
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
归并排序
\end_layout

\begin_layout Standard
要将一个数组排序，可以先将它分成两半分别排序，然后将结果归并起来.
\end_layout

\begin_layout Subsection
自顶向下的归并排序
\end_layout

\begin_layout Subsection
自底向上的归并排序
\end_layout

\begin_layout Standard
首先将数据集分解为一组只有一个元素的数组.
 然后通过创建一组左右子数组将它们慢慢合并起来，每次合并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/sort/归并排序.png
	lyxscale 30
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
快速排序
\end_layout

\begin_layout Standard
首先要在列表中选择一个元素作为基准值(pivot), 数据排序围绕基准值进行，将列表中小于
\series bold
基准值
\series default
的元素移到数组的底部，将大于基准值的元素移到数组的顶部.
 接着再拆分数组, 在小数组中再选择一个
\series bold
基准值
\series default
处理.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\backslash

\begin_inset Graphics
	filename img/sort/快速排序.png
	lyxscale 30
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
快速排序
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
堆排序(Heap Sort)
\end_layout

\begin_layout Standard
堆积是一个近似完全二叉树的结构，并同时满足堆积的性质: 即子结点的键值或索引总是小于(或者大于)它的父节点.
 (堆不是二叉树)
\end_layout

\begin_layout Section
计数排序(Counting Sort)
\end_layout

\begin_layout Standard
计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中.
  作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数.
 
\end_layout

\begin_layout Standard
新建一个数组, 将原有数据按下标放入新的数组.
\end_layout

\begin_layout Section
桶排序(Bucket Sort)
\end_layout

\begin_layout Standard
计数排序的升级版, 将计数排序的新数组按映射关系多放几个数据.
 比如 下标为1 可以放 10,11,12 ; 下标为2放20,22 等.
\end_layout

\begin_layout Section
基数排序(Radix Sort)
\end_layout

\begin_layout Standard
将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零.
 然后，从最低位(个,十,百,千)开始，依次进行一次排序.
 这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列.
 过程可以使用桶排序的方式将数据(以当前位映射)放入桶中.
\end_layout

\begin_layout Section
分类
\end_layout

\begin_layout Standard
内排序(在内存中的排序)
\end_layout

\begin_layout Itemize
插入排序: 直接插入排序、折半插入、希尔排序 
\end_layout

\begin_layout Itemize
交换排序: 冒泡排序、快速排序 
\end_layout

\begin_layout Itemize
选择排序: 简单选择排序、锦标赛排序、堆排序 
\end_layout

\begin_layout Itemize
归并排序: 二路归并
\end_layout

\begin_layout Itemize
分布排序: 基数排序、MSD 基数排序、LSD 基数排序
\end_layout

\begin_layout Standard
外排序
\end_layout

\begin_layout Section
优先队列
\end_layout

\begin_layout Chapter
字符串
\end_layout

\begin_layout Standard
倒排索引(Inverted index) : 一般索引是根据已知去计算结果, 倒排索引根据计算结果查询已知.
\end_layout

\begin_layout Standard
BF(Brute Force)算法:暴力搜索,穷举搜索
\end_layout

\begin_layout Standard
RK (Rabin-Karp)算法: 使用散列函数以在文本中搜寻单个模式串的字符串搜索算法单次匹配, 取子串,求hash(可能需要model 大素数),
 比较hash.
\end_layout

\begin_layout Standard
KMP 算法: 
\end_layout

\begin_layout Standard
AC 自动机: 
\end_layout

\begin_layout Standard
后缀数组: 
\end_layout

\begin_layout Standard
后缀树: 
\end_layout

\begin_layout Chapter
树
\end_layout

\begin_layout Standard
树是一种非线性的数据结构.
\end_layout

\begin_layout Standard

\series bold
二叉树
\series default
: 每个节点最多只有两个分支(即不存在分支度大于2的节点)的树结构.
 通常分支被称作“左子树”或“右子树”.
 没有子节点的节点称为
\series bold
叶子
\series default
.
\end_layout

\begin_layout Standard
二叉树的分支具有左右次序，不能随意颠倒.
 二叉树的第
\begin_inset Formula $i$
\end_inset

层至多拥有
\begin_inset Formula $2^{i-1}$
\end_inset

个节点; 深度为
\begin_inset Formula $k$
\end_inset

的二叉树至多总共有
\begin_inset Formula $2^{k}-1$
\end_inset

个节点(定义根节点所在深度
\begin_inset Formula $k_{0}=0$
\end_inset

), 而总计拥有节点数符合的, 称为“满二叉树”; 深度为 k有 n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对
一对应时，称为完全二叉树.完全二叉树 在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在
\series bold
右边
\series default
缺少连续若干节点，则此二叉树为完全二叉树 .
\end_layout

\begin_layout Standard

\series bold
二叉查找树(binary search tree) 
\series default
当前根节点的左边全部比根节点小, 当前根节点的右边全部比根节点大
\end_layout

\begin_layout Section
红黑树
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/644px-Red-black_tree_example.svg.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Black Red Tree
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
红黑树 一种自平衡二叉查找树.

\series default
 红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色.
 在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求: 
\end_layout

\begin_layout Enumerate
节点是红色或黑色.
\end_layout

\begin_layout Enumerate
根是黑色.
\end_layout

\begin_layout Enumerate
所有叶子(
\series bold
NIL节点
\series default
)都是黑色.
\end_layout

\begin_layout Enumerate
每个红色节点必须有两个黑色的子节点.
 (
\series bold
 从每个叶子到根的所有路径上不能有两个连续的红色节点
\series default
.
 可以有黑色的,因为叶子节点必须是黑色的)
\end_layout

\begin_layout Enumerate

\series bold
从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点.
 违反此规则的称为黑色违规.
\end_layout

\begin_layout Standard
红黑树并不是标准平衡二叉树，它以性质 
\series bold
5
\series default
 作为一种平衡方法，使自己的性能得到了提升.
 
\end_layout

\begin_layout Standard

\series bold
黑色深度(Black Depth)
\series default
 从根节点到该节点的路径上黑色节点的个数
\end_layout

\begin_layout Standard

\series bold
黑色高度
\series default
 从根节点到叶节点(
\series bold
NIL节点
\series default
)的路径上黑色节点的个数，叫做树的黑色高度.
 
\end_layout

\begin_layout Standard

\series bold
红黑树的关键属性
\series default
: 从根到最远的叶子节点的路径的长度不超过从根到最近叶子的路径的两倍.
\end_layout

\begin_layout Standard
因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同.
 然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质.
 恢复红黑树的性质需要少量(
\begin_inset Formula ${\displaystyle \text{O}(\log n)}$
\end_inset

) 的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次).
 虽然插入和删除很复杂，但操作时间仍可以保持为
\begin_inset Formula ${\displaystyle O(\log n)}$
\end_inset

次.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Red-black_tree_example_(B-tree_analogy).svg.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
类比4阶B tree
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
红黑树的旋转
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/black-red-roate.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
红黑树的旋转
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
左旋步骤:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    private void rotateLeft(Entry<K,V> p) {
\end_layout

\begin_layout Plain Layout

        if (p != null) {
\end_layout

\begin_layout Plain Layout

            Entry<K,V> r = p.right; // p 是上图中右侧的 x, r 就是 y
\end_layout

\begin_layout Plain Layout

            p.right = r.left; // x 的右子树(转之前y所在的点)成了 y 的左子树 β 
\end_layout

\begin_layout Plain Layout

            if (r.left != null)//
\end_layout

\begin_layout Plain Layout

                r.left.parent = p;// 修改β 的父亲为x
\end_layout

\begin_layout Plain Layout

            r.parent = p.parent; // 修改r(图中y) 的父为 p(图中x) 的父
\end_layout

\begin_layout Plain Layout

            if (p.parent == null)
\end_layout

\begin_layout Plain Layout

                root = r; //要是 x 没有父亲，那 y 就是最老的根节点
\end_layout

\begin_layout Plain Layout

            else if (p.parent.left == p)// 如果x有父亲并且是它父亲的左子树
\end_layout

\begin_layout Plain Layout

                p.parent.left = r;// x 的父亲现在认 y 为左子树
\end_layout

\begin_layout Plain Layout

            else // 如果x有父亲并且是它父亲的右子树
\end_layout

\begin_layout Plain Layout

                p.parent.right = r;
\end_layout

\begin_layout Plain Layout

            r.left = p;
\end_layout

\begin_layout Plain Layout

            p.parent = r;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 private void rotateRight(Entry<K,V> p) {         if (p != null) {     
        Entry<K,V> l = p.left;             p.left = l.right;             if
 (l.right != null) l.right.parent = p;             l.parent = p.parent;     
        if (p.parent == null)                 root = l;             else
 if (p.parent.right == p)                 p.parent.right = l;             else
 p.parent.left = l;             l.right = p;             p.parent = l;     
    }     }
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
插入
\end_layout

\begin_layout Standard

\series bold
插入
\series default
一个节点后要担心违反特征 4 和 5.
 
\series bold
把插入的节点直接染成红色
\series default
，这样就不会影响特征 5，只要专心调整满足特征 4 就好了.
 这样比同时满足 4、5 要简单一些.
\end_layout

\begin_layout Standard
染成红色后，我们只要关心父节点是否为红，如果是红的，就要把父节点进行变化，让父节点变成黑色，或者换一个黑色节点当父亲，这些操作的同时不能影响不同路径上的黑色节点
数一致的规则.
 
\end_layout

\begin_layout Subsubsection
插入、染红后的调整有 2 种情况: 
\end_layout

\begin_layout Paragraph
情况1.父亲节点和叔叔节点都是红色: 
\end_layout

\begin_layout Section

\series bold
AVL树
\end_layout

\begin_layout Standard
是最早被发明的自平衡二叉查找树, 在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树.
 查找、插入和删除在平均和最坏情况下的时间复杂度都是
\begin_inset Formula $O(\log{n})$
\end_inset

.
 
\end_layout

\begin_layout Section

\series bold
B树(B-tree)(B-树)
\series default
 
\end_layout

\begin_layout Standard
B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个.
 因为与红黑树一样，一棵含n个结点的B树的高度也为O(lgn)，但可能比一棵红黑树的高度小许多，应为它的分支因子比较大.
 所以，B树可以在O(logn)时间内，实现各种如插入(insert)，删除(delete)等动态集合操作.
 
\end_layout

\begin_layout Standard
B树有个概念叫
\series bold
阶
\series default
, 其实就是一个节点最对可以有多少个子节点的那个数.一般用字母M表示.M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉.
\end_layout

\begin_layout Standard
B树中每一个内部节点会包含一定数量的
\series bold
键
\series default
，键将节点的
\series bold
 子树 
\series default
分开(即键是用来分
\series bold
子节点
\series default
树的).
 例如，如果一个内部节点有3个子节点(子树)，那么它就必须有两个键:  a1 和 a2 .
 左边子树的所有值都必须小于 a1 ，中间子树的所有值都必须在 a1 和a2 之间，右边子树的所有值都必须大于 a2 .
 
\end_layout

\begin_layout Itemize
所有节点关键字是按递增次序排列，并遵循左小右大原则；
\end_layout

\begin_layout Itemize
树中每个结点最多含有m个孩子(m>=2)；
\end_layout

\begin_layout Itemize
除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子(其中ceil(x)是一个取上限的函数, 即向上取整)；
\end_layout

\begin_layout Itemize
若根结点不是叶子结点，则至少有2个孩子(特殊情况: 没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点)；
\end_layout

\begin_layout Itemize
所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;
\end_layout

\begin_layout Itemize
每个非终端结点中包含有n个关键字信息:  (n，P0，K1，P1，K2，P2，......，Kn，Pn).
 其中:         
\end_layout

\begin_layout Itemize
a)   Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki.
         
\end_layout

\begin_layout Itemize
b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1).
    
\end_layout

\begin_layout Itemize
 c)   关键字的个数n必须满足:  [ceil(m / 2)-1]<= n <= m-1
\end_layout

\begin_layout Itemize
B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理(磁盘数据存储是采用块的形式存储的，每个
块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来)把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二
叉树少了，减少数据查找的次数和复杂度;
\end_layout

\begin_layout Section
B+tree: 
\end_layout

\begin_layout Standard
是应文件系统所需而产生的一种B-tree的变形树
\end_layout

\begin_layout Standard
B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；
\end_layout

\begin_layout Standard
B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到.
 所以每次数据查询的次数都一样；
\end_layout

\begin_layout Standard
B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针.
 
\end_layout

\begin_layout Standard
非叶子节点的子节点数=关键字数
\end_layout

\begin_layout Standard
B*树: 一棵丰满的B+树.
 
\end_layout

\begin_layout Section

\series bold
R(Rectangle)树
\series default
: 
\end_layout

\begin_layout Standard
处理空间存储问题
\end_layout

\begin_layout Standard
R树是B树在高维空间的扩展，是一棵平衡树.
 每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中.
 根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可.
 这种方式使我们不必遍历所有数据即可获得答案，效率显著提高.
 
\end_layout

\end_body
\end_document
