# 图

图由边的集合及顶点的集合组成. 边由顶点对(v1,v2)定义,v1和v2分别是图中的两个顶点. 顶点也有权重,也称为成本. 如果一个图的顶点对是有序的,则可以称之为有向图. 在对有向图中的顶点对排序后,便可以在两个顶点之间绘制一个箭头. 有向图表明了顶点的流向. 计算机程序中用来表明计算方向的流程图就是一个有向图的例子.

![有向图](../static-resource/image/图/有向图.png)
图1-1 有向图

如果图是无序的,则称之为无序图,或无向图.

![无序图](../static-resource/image/图/无序图.png)
图1-2:无序图

图中的一系列顶点构成**路径**，路径中所有的顶点都由边连接. 路径的长度用路径中第一个顶点到最后一个顶点之间边的数量表示. 由指向自身的顶点组成的路径称为**环**，环的长度为0.

**圈**是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同. 无论是有向图还是无向图，只要是没有重复边或重复顶点的圈，就是一个**简单圈**. 除了第一个和最后一个顶点以外，路径的其他顶点有重复的圈称为**平凡圈**.

如果两个顶点之间有路径，那么这两个顶点就是**强**连通的，反之亦然. 如果有向图的所有的顶点都是强连通的，那么这个有向图也是强连通的.

我们将表示图的边的方法称为邻接表或者邻接表数组. 这种方法将边存储为由顶点的相邻顶点列表构成的数组,并以此顶点作为索引. 使用这种方案,当我们在程序中引用一个顶点时,可以高效地访问与这个顶点相连的所有顶点的列表. 比如,如果顶点2与顶点0、1、3、4相连,并且它存储在数组中索引为2的位置,那么,访问这个元素,我们可以访问到索引为2的位置处由顶点0、1、3、4组成的数组.

## 图类

### 表示顶点

创建图类的第一步就是要创建一个`Vertex`类来保存顶点和边. 这个类的作用与链表和二叉搜索树的`Node`类一样. `Vertex`类有两个数据成员: 一个用于标识顶点，另一个是表明这个顶点是否被访问过的布尔值. 它们分别被命名为`label`和`wasVisited`. 这个类只需要一个函数，那就是为顶点的数据成员设定值的构造函数. `Vertex`类的代码如下所示:

```js
function Vertex(label) {
   this.label = label;
   this.wasVisited = wasVisited
}
```

#### 存储顶点

我们将所有顶点保存到数组中，在图类里，可以通过它们在**数组中的位置**引用它们. 如图所示

![存储顶点](../static-resource/image/图/存储顶点.png)

### 表示边

我们将表示图的边的方法称为邻接表或者邻接表数组. 这种方法将边存储为由顶点的相邻顶点列表构成的数组,并以此顶点作为索引. 使用这种方案,当我们在程序中引用一个顶点时,可以高效地访问与这个顶点相连的所有顶点的列表. 比如,如果顶点C与顶点A、B、D、E相连,并且它存储在数组中索引为2的位置,那么,访问这个元素,我们可以访问到索引为2的位置处由顶点A、B、D、E组成的数组.

![邻接表](../static-resource/image/图/邻接表.png)
图1-3:邻接表

### 构建图

```js
function Graph(v) {// 初始化
  this.vertices = v;
  this.edges = 0;  // 边数
  this.adj = [];   // 记录顶点数组
  for (var i = 0; i < this.vertices; ++i) {
    this.adj[i] = [];
    this.adj[i].push("");// 添加相邻顶点?
  }
  this.addEdge = addEdge;
  this.toString = toString;
}
```

这个类会记录一个图表示了多少条边,并使用一个长度与图的顶点数相同的数组来记录顶点的数量. 通过for循环为数组中的每个元素添加一个子数组来存储所有的相邻顶点,并将所有元素初始化为空字符串.

addEdge()函数定义如下:

```js
function addEdge(v, w) {
this.adj[v].push(w);
this.adj[w].push(v);
this.edges++;
}
```

当调用这个函数并传入顶点A和B时,函数会先查找顶点A的邻接表,将顶点B添加到列表中,然后再查找顶点B的邻接表,将顶点A加入列表. 最后,这个函数会将边数加1.

## 无向图

## 搜索图

在图上可以执行两种基础搜索:深度优先搜索和广度优先搜索.

### 深度优先搜索

深度优先搜索包括从一条路径的起始顶点开始追溯,直到到达最后一个顶点,然后回溯,继续追溯下一条路径,直到到达最后的顶点,如此往复,直到没有路径为止. 这不是在搜索特定的路径,而是通过搜索来查看在图中有哪些路径可以选择. 图1-4演示了深度优先搜索的搜索过程.

![深度优先搜索](../static-resource/image/图/深度优先搜索.png)

图1-4 深度优先搜索

深度优先搜索算法比较简单:访问一个没有访问过的顶点,将它标记为已访问,再递归地去访问在初始顶点的邻接表中其他没有访问过的顶点.
