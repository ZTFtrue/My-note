# 数据结构

## 数组

[数组](https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84 "数组")

## 列表

## 栈

## 队列

## 链表

### 数组的缺点

数组不总是组织数据的最佳数据结构，原因如下. 在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再要加入新的元素就会非常困难. 在数组中，添加和删除元素也很麻烦，因为需要将数组中的其他元素向前或向后平移，以反映数组刚刚进行了添加或删除操作.

**除了对数据的随机访问，链表几乎可以用在任何可以使用一维数组的情况中. 如果需要随机访问，数组仍然是更好的选择.**

链表是由一组节点组成的集合. 每个节点都使用一个对象的引用指向它的后继. 指向另一个节点的引用叫做链. 图6-1展示了一个链表.

![链表](../static-resource/image/链表.png)

图6-1: 链表

数组元素靠它们的位置进行引用，链表元素则是靠相互之间的关系进行引用. 在图6-1中，我们说bread跟在milk后面，而不说bread是链表中的第二个元素. 遍历链表，就是跟着链接，从链表的首元素一直走到尾元素(但这不包含链表的头节点，头节点常常用来作为链表的接入点). 图中另外一个值得注意的地方是，链表的尾元素指向一个null节点.

然而要标识出链表的起始节点却有点麻烦，许多链表的实现都在链表最前面有一个特殊节点，叫做头节点. 经过改造之后，图6-1中的链表成了下面的样子.

![有头节点的链表](../static-resource/image/有头节点的链表.png)

图6-2: 有头节点的链表

尽管从链表的头节点遍历到尾节点很简单，但反过来，从后向前遍历则没那么简单. 通过给Node对象增加一个属性，该属性存储指向前驱节点的链接，这样就容易多了. 此时向链表插入一个节点需要更多的工作，我们需要指出该节点正确的前驱和后继. 但是在从链表中删除节点时，效率提高了，不需要再查找待删除节点的前驱节点了. 图6-5演示了双向链表的工作原理.

![双向链表](../static-resource/image/双向链表.png)

图6-2: 双向链表

### 循环链表

循环链表和单向链表相似，节点类型都是一样的. 唯一的区别是，在创建循环链表时，让其头节点的next属性指向它本身，即:

```js
  head.next = head
```

如果你希望可以从后向前遍历链表，但是又不想付出额外代价来创建一个双向链表，那么就需要使用循环链表. 从循环链表的尾节点向后移动，就等于从后向前遍历链表.

只需要修改一处，就将单向链表变成了循环链表. 但是其他一些方法需要修改才能工作正常. 比如，，原来的方式在循环链表里会陷入死循环. while循环的循环条件需要修改，需要检查头节点，当循环到头节点时退出循环.

### 链表的其他方法

为了使链表更好用，需要再定义其他一些方法. 在接下来的练习中，就有机会实现几个这样的方法，包括下面几种.

- advance(n)
    在链表中向前移动n个节点.

- back(n)
    在双向链表中向后移动n个节点.

- show()
    只显示当前节点.

## 字典

字典是一种以键-值对形式存储数据的数据结构，就像电话号码簿里的名字和电话号码一样. 要找一个电话时，先找名字，名字找到了，紧挨着它的电话号码也就找到了. 这里的键是指你用来查找的东西，值是查找得到的结果.

## 集合

集合(set)是一种包含不同元素的数据结构. 集合中的元素称为成员. 集合的两个最重要特性是: 首先，集合中的成员是无序的；其次，集合中不允许相同成员存在. 集合在计算机科学中扮演了非常重要的角色，然而在很多编程语言中，并不把集合当成一种数据类型. 当你想要创建一个数据结构，用来保存一些独一无二的元素时，比如一段文本中用到的单词，集合就变得非常有用. 本章讨论如何在JavaScript中创建Set类.

add()方法的定义:

```js
function add(data) {
    if (this.dataStore.indexOf(data) < 0) {
        this.dataStore.push(data);
        return true;
    }
    else {
        return false;
    }
}
```

因为集合中不能包含相同的元素，所以，使用add()方法将数据存储到数组前，先要确保数组中不存在该数据. 我们使用indexOf()检查新加入的元素在数组中是否存在. 如果找到，该方法返回该元素在数组中的位置；如果没有找到，该方法返回-1. 如果数组中还未包含该元素，add()方法会将新加元素保存到数组中并返回true；否则，返回false. 将add()方法的返回值定义为布尔类型，可以明确告诉我们是否将一个元素成功加入到了集合中.

## 树

树可以分为几个层次，根节点是第0层，它的子节点是第1层，子节点的子节点是第2层，以此类推. 树中任何一层的节点可以都看做是子树的根，该子树包含根节点的子节点，子节点的子节点等. 我们定义树的层数就是树的深度. 其中，每个节点都有一个与之相关的值，该值有时被称为键.

沿着一组特定的边，可以从一个节点走到另外一个与它不直接相连的节点. 从一个节点到另一个节点的这一组边称为路径，在图中用虚线表示. 以某种特定顺序访问树中所有的节点称为树的遍历.

在计算机科学里，自上而下的树则是个由来已久的习惯.

### 二叉树和二叉查找树

二叉树每个节点的子节点不允许超过两个. 通过将子节点的个数限定为2，可以写出高效的程序在树中插入、查找和删除数据.

二叉树具有一些特殊的计算性质，使得在它们之上的一些操作异常高效.

```java
// 定义一个节点java代码
class Node{
  public int value;
  public Node left;
  public Node right;
  public Node(int v){
      this.value=v;
      this.left=null;
      this.right=null;
  }
}
```

#### 二叉查找树

二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中. 这一特性使得查找的效率很高，对于数值型和非数值型的数据，比如单词和字符串，都是如此.

#### 遍历二叉树

有三种遍历BST的方式: 中序、先序和后序. 中序遍历按照节点上的键值，以升序访问BST上的所有节点. 先序遍历先访问根节点，然后以同样方式访问左子树和右子树. 后序遍历先访问叶子节点，从左子树到右子树，再到根节点.

- 广度优先遍历(BFS,Breadth First Traversal)
  - 一层一层的遍历
- 深度遍历(DFS,Depth First Traversals)
  - 先序遍历 Inorder Traversal (Left-Root-Right)
  - 中序遍历 Preorder Traversal (Root-Left-Right)
  - 后序遍历 Postorder Traversal (Left-Right-Root)

## 图

图由边的集合及顶点的集合组成. 顶点也有权重,也称为成本. 如果一个图的顶点对是有序的,则可以称之为有向图. 在对有向图中的顶点对排序后,便可以在两个顶点之间绘制一个箭头. 有向图表明了顶点的流向. 计算机程序中用来表明计算方向的流程图就是一个有向图的例子.

- 无向图: 即图的边没有方向，边一般用弧形括号表示()
- 有向图: 图的边有方向，边一般用尖括号表示<>
- 完全图: 图的每两个顶点之间有边链接
- 连通图: 图的每两个顶点之间有路径链接
