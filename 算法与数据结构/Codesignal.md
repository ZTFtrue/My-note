# Codesignal

巴特为他的朋友们设置了一个圆形扑克桌，这样桌上的每个座位都有相同数量的扑克筹码. 但是当Bart没有看时，有人重新安排了所有芯片，以便它们不再均匀分布！现在巴特需要重新分配筹码，以便在他的朋友到达之前每个座位都有相同的号码. 但巴特非常细致: 为了确保他在这个过程中没有丢失任何筹码，他只会在相邻席位之间移动筹码. 而且，他一次只移动一个芯片. 为了使芯片恢复平衡，Bart需要做出的最小芯片移动次数是多少？

例
对于筹码= [1,5,9,10,5]，输出应为
pokerChips(筹码)= 12.
该数组表示一个循环表，因此我们允许在数组中的最后一个索引和第一个索引之间移动筹码. 因此Bart可以通过以下步骤(1-indexed)使芯片恢复平衡:

- 将2个筹码从座位2移动到座位1(2个动作);
- 将3个筹码从座位3移动到座位2(3个动作);
- 将3个筹码从座位5移动到座位1(3个动作);
- 将4个筹码从座位4移动到座位5(4个移动).

在这12个移动序列之后，每个座位将有6个筹码，并且没有更少的动作序列做同样的事情.
