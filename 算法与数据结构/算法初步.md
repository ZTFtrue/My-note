# 算法初步

## 辗转相除法

## 更相减损术

## 秦九韶算法

## 排序

## 散列碰撞处理

散列是一种常用的数据存储技术，散列后的数据可以快速地插入或取用. 散列使用的数据结构叫做散列表. 在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下，比如查找一组数据中的最大值和最小值.

我们的散列表是基于数组进行设计的. 数组的长度是预先设定的，如有需要，可以随时增加. 所有元素根据和该元素对应的键，保存在数组的特定位置，该键和我们前面讲到的字典中的键是类似的概念. 使用散列表存储数据时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度.

理想情况下，散列函数会将每个键值映射为一个唯一的数组索引. 然而，键的数量是无限的，数组的长度是有限的(理论上，在JavaScript中是这样)，一个更现实的目标是让散列函数尽量将键均匀地映射到数组中.

即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象称为碰撞(collision)，当碰撞发生时，我们需要有方案去解决. 本章稍后部分将详细讨论如何解决碰撞.

### 霍纳算法

字符串中各字符的ASCII码值,求和时每次要乘以一个质数,

将乘法转换位加法.

```js
 function betterHash(string, arr) {
   const H = 37;// 必须是质数
   var total = 0;
   for (var i = 0; i < string.length; ++i) {
       total += H * total + string.charCodeAt(i);
   }
   total = total % arr.length;
   return parseInt(total);
 }
```

### 开链法

当碰撞发生时，我们仍然希望将键存储到通过散列算法产生的索引位置上，但实际上，不可能将多份数据存储到一个数组单元中. 开链法是指实现散列表的底层数组中，每个数组元素又是一个新的数据结构，比如另一个数组，这样就能存储多个键了. 使用这种技术，即使两个键散列后的值相同，依然被保存在同样的位置，只不过它们在第二个数组中的位置不一样罢了.

实现开链法的方法是: 在创建存储散列过的键值的数组时，通过调用一个函数创建一个新的空数组，然后将该数组赋给散列表里的每个数组元素，这样就创建了一个二维数组.
线性探测法
线性探测法隶属于一种更一般化的散列技术: 开放寻址散列. 当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空. 如果为空，就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止. 该技术是基于这样一个事实: 每个散列表都会有很多空的单元格，可以使用它们来存储数据.

### 选择那种方法

当存储数据使用的数组特别大时，选择线性探测法要比开链法好. 这里有一个公式，常常可以帮助我们选择使用哪种碰撞解决办法: 如果数组的大小是待存储数据个数的1.5倍，那么使用开链法；如果数组的大小是待存储数据的两倍及两倍以上时，那么使用线性探测法.

### 二分法查找

二分法插入排序(二分排序)

在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left<right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上.
