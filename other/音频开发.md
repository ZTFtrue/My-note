#

- 音调:振动频率。每秒钟振动400次，就称频率为400HZ。
- 振幅就是振动的大小。
- 音色由振动的波形决定，同样一个音，钢琴和长笛音色就不一样。

乐音的波形往往比较有规律，比如钢琴弦的振动；而杂音的波形往往是毛燥的、带有尖刺的，比如刮玻璃的声音。

同时发出的两个或多个声音，合成后的听觉效果大相径庭。频率完全一致的，听起来十分融合、和谐。

频率越高，人耳感觉的音调就越高。频率增加一倍，也叫提高一个倍频程，音调就提高一个调也叫提高一个八度。

## 音程

音程是指两个音之间的距离(高低关系)，单位是以度计算。音程概略可分为“旋律音程”搭“和声音程”，通常用半音或全音来表示。音程是音乐中非常重要的概念，它可以用来描述和分析音乐中的旋律、和声以及和弦。

- 旋律音程是指两个音符一先一后个发出声音。
- 和声音程是指这两个音同时发响，在谱子上显示为上下对齐的形态（二度的和声音程为左低右高紧挨在一起的形态）

在音程中，上方的音叫做冠音，就如同大树的树冠一样；下方的音叫做根音。在识别一个音程时，只要看根音与冠音之间的距离即可判定这个音程。

### 度数

度数指的是两个音之间包含的基本音名或唱名的数量（含自身）,不限定起点。
例如，do－fa的度数是四度，包含了do、re、mi、fa四个唱名；do－do1的度数是八度，包含了do、re、mi、fa、sol、la、si、do1八个唱名。
度数即是从根音数到冠音所包含的音级数目。五线谱上的每一条线和每一个间都是一度。两个音同在一条线上，或者同在一个间里的时候，这两个音的音程关系叫做“一度”，或者叫做：“同度”。

 音乐上有一个国际标准音叫做A音，他的频率是`440`赫兹，以这个A音为基准向下延伸3个八度音程，向上扩展5个八度音程，一共8个八度音程就包括了人声所能表现的声音的全音频范围了。这8个八度就叫做音调。

### 音数

音数是指音程之间所包含的半音与全音数目之和，用整数与分数1/2来表示。半音的音数为1/2、全音的音数为1，两个半音相加的音数为1/2＋1/2＝1。

### 音程分类

由音数和度数共同来构成音程的名称。如大二度、小七度、纯五度、减四度、增六度等，可简称为大二、小七、纯五、减四、增六等。

音程度数前的文字“大”、“小”、“纯”，只能在固定的度数前使用，具体的规定是：一度、四度、五度、八度音程要用“纯”字来表示，不能用“大”、“小”来标记；二度、三度、六度、七度要用“大”、“小”来标记，而不能用“纯”字来标记。

音程可以根据距离的大小和品质来分类。以下是一些常见的音程及其特征：

纯音程（Perfect Intervals）：纯音程是最稳定、最和谐的音程，包括纯一度、纯四度、纯五度和纯八度。它们的比例关系是非常简单的整数比例。

大调音程（Major Intervals）：大调音程包括大二度、大三度、大六度和大七度。这些音程的距离比纯音程稍微大一些。

小调音程（Minor Intervals）：小调音程包括小二度、小三度、小六度和小七度。这些音程的距离比纯音程稍微小一些。

增音程（Augmented Intervals）：增音程比完全大调或纯音程要大一个半音。

减音程（Diminished Intervals）：减音程比完全小调或纯音程要小一个半音。

音程在音乐中扮演着重要的角色，因为它们决定了旋律和和声的特征和质感。通过理解音程，音乐家可以更好地理解音乐的结构，并且能够更加准确地演奏、创作和分析音乐。

<https://zh.wikipedia.org/wiki/%E9%9F%B3%E7%A8%8B>

协和音程：

- 极完全协和音程：纯一度、纯八度
- 完全协和音程：纯四度、纯五度
- 不完全协和音程：大、小三度，大、小六度
- 不协和音程：大、小二度，大、小七度，所有增、减、倍增、倍减音程

### 单音程和复音程

单音程比较简单些，它是指在一个八度之内的音程，叫做单音程。超过一个八度之外的音程叫复音程。

单音程的称呼比较容易一些，是几度就可以直接称呼。比如大三度、纯八度、增二度、小七度等等。

复音程相对来讲就比较复杂一些。简单的办法可以用“加七”：把现有的度数加上七度，然后一共是几度就直接称呼它的度数。

### 音程的转位

极完全协和音程和完全协和音程由于过分协和，听起来空、单薄、和声效果差，在多声部音乐中只能适当应用，而不完全协和音程的声音则较为丰满、和谐，在多声部音乐中常用。

音程的转位：就是把音程上下两个音的位置颠倒过来（根音和冠音互相倒置）上方音成为下方音，下方音成为上方音。这就是音程的换位。

音程转位可以在一个八度之内，也可以超过一个八度。可以单独移动根音和冠音，也可以将根音和冠音同时移位。

极完全协和音程和完全协和音程由于过分协和，听起来空、单薄、和声效果差，在多声部音乐中只能适当应用，而不完全协和音程的声音则较为丰满、和谐，在多声部音乐中常用。

### 十二平均律

将一个八度平均分成十二等份，每等分称为半音，音高八度音指的是频率乘上二倍。
八度音的频率分为十二等分，即是分为十二项的 __等比数列__，也就是每个音的频率为前一个音的2的12次方根倍：

其近似值约为
${\displaystyle \,{\sqrt[{12}]{2}}=2^{\frac {1}{12}}\approx \,}
1.0594630943593
{\displaystyle 1.0594630943593}$ 倍。

## 等响度曲线

人耳对声音音调的感觉，与声音的频率有关，但不是正比关系，而是 __对数关系__，通常用频率的倍数或者对数关系来表示音调。

等响度曲线描述了在不同频率下人类听觉系统对声音响度的感知。它显示了相同响度水平下不同频率声音的相对强度，因为人类听觉系统对不同频率的声音响度感知并不相同。

人类对低频声音相对于高频声音更不敏感，因此在相同的响度水平下，低频声音需要更大的声压级（音量，dB）才能被感知到与高频声音相同的响度。声压级相同的两个不同频率的声音,人耳不一定都能听到。

声压级和响度码是两个不同的概念，它们用于描述声音的特征，但从不同的角度进行了定义。

- 声压级（Sound Pressure Level，简称SPL）：声压级是描述声音强度的物理量，通常用分贝（dB）来表示。它是声音的压力相对于参考值（通常为20微帕）的对数比。声压级是用来量化声音在空气中传播时的强度，是声学工程和环境噪音控制中常用的指标之一。

- 响度（Loudness）：响度是描述声音响度感知的心理量，与声音的物理强度相关但不完全相同。响度是指人对声音强度的主观感知，与声音的频率和声压级等因素有关。响度通常以响度等级（Loudness Level）来表示，单位是斯特（sone），这是基于主观听觉实验得出的一种量度。

虽然声压级和响度码都与声音的强度有关，但声压级是一种物理量，可以直接通过测量声音的压力得出，而响度码则更关注于人类听觉系统对声音强度的主观感知。

## 滤波器

### Equalizer

Frequency Bands: Equalizers typically have multiple frequency bands that can be adjusted. These can range from simple two-band bass and treble adjustments to sophisticated 31-band graphic equalizers.

Identify the Frequency Range:

1. Low Frequencies (20-200 Hz): Controls bass.
2. Mid Frequencies (200 Hz - 4 kHz): Affects the clarity and presence of vocals and instruments.
3. High Frequencies (4 kHz - 20 kHz): Manages treble and brightness.

#### Types of Equalizers

##### Graphic Equalizer

 Provides a visual representation with sliders for each frequency band.

###### Parametric Equalizer

Offers more control, allowing adjustments to the frequency, bandwidth (Q factor), and gain for each band.

__Peaking Filters__: Boost or cut frequencies around a specific center frequency.

High-pass and Low-pass Filters: Some parametric equalizers offer additional high-pass and low-pass filter options.

###### Shelving Equalizer

Adjusts frequencies above (high shelf) or below (low shelf) a certain point.

###### Peaking Equalizer

Boosts or cuts frequencies around a center point.

### 滤波器的种类

 Infinite Impulse Response (IIR) and Finite Impulse Response (FIR) are two fundamental types of digital filters used in audio processing and many other applications. Here's an overview of each, including their characteristics, advantages, and disadvantages:

#### Finite Impulse Response (FIR) Filters

##### Characteristics

- __Impulse Response__: The output responds only for a finite number of input samples.
- __Structure__: Composed of a series of coefficients applied to current and past input values.
- __Stability__: Always stable because the output is based solely on past and current inputs.
- __Phase Response__: Can be designed to have a linear phase response, meaning all frequency components of the signal are delayed by the same amount, preserving the wave shape of signals.
- __Implementation__: Generally requires more computational resources (more multiplications and additions) compared to IIR filters for the same level of performance.

##### Equation

The output \( y[n] \) of an FIR filter is given by:
\[ y[n] = \sum_{k=0}^{M-1} b_k \cdot x[n-k] \]
where:

- \( x[n] \) is the input signal,
- \( b_k \) are the filter coefficients,
- \( M \) is the filter order (number of taps).

##### Advantages

- __Stability__: Always stable as there are no feedback elements.
- __Linear Phase__: Can be designed to have a perfectly linear phase response.
- __Design Simplicity__: Easier to design and implement for specific frequency responses.

##### Disadvantages

- __Computational Cost__: Requires more computations, especially for high-order filters.
- __Memory Usage__: Needs more memory to store past input samples and filter coefficients.

#### Infinite Impulse Response (IIR) Filters

##### Characteristics

- __Impulse Response__: The output can theoretically last indefinitely due to feedback elements.
- __Structure__: Uses both current and past input values as well as past output values.
- __Stability__: Can be unstable if not designed carefully, as feedback can lead to runaway conditions.
- __Phase Response__: Typically has a non-linear phase response, which can distort the phase of the input signal.
- __Implementation__: Generally more computationally efficient (fewer multiplications and additions) than FIR filters for achieving a similar performance.

##### Equation

The output ￥\( y[n] \)$ of an IIR filter is given by:
\[ y[n] = \sum_{k=0}^{N} a_k \cdot y[n-k] + \sum_{k=0}^{M} b_k \cdot x[n-k] \]
where:

- \( x[n] \) is the input signal,
- \( y[n] \) is the output signal,
- \( b_k \) and \( a_k \) are the filter coefficients for input and output, respectively,
- \( N \) and \( M \) are the filter orders.

##### Advantages

- __Efficiency__: Requires fewer coefficients and thus less computation for a given performance level compared to FIR filters.
- __Memory Usage__: Generally requires less memory due to fewer coefficients and storage needs.

##### Disadvantages

- __Stability__: Can be unstable if not carefully designed due to feedback loops.
- __Non-Linear Phase__: Usually has a non-linear phase response, which can cause phase distortion.
- __Design Complexity__: Designing stable IIR filters with specific characteristics can be more complex.

#### Practical Considerations

##### When to Use FIR Filters

- __Linear Phase Requirements__: When phase linearity is critical, such as in data communications and some audio applications.
- __Stability Assurance__: When stability is a primary concern and should be guaranteed regardless of coefficient values.
- __Simple Design__: When ease of design and implementation for specific frequency responses is needed.

##### When to Use IIR Filters

- __Computational Efficiency__: When computational resources are limited and efficiency is crucial.
- __Memory Constraints__: When memory usage needs to be minimized.
- __Low-Order Filters__: When a lower order filter can achieve the desired performance, as IIR filters can achieve sharp cutoffs with fewer coefficients.

Both FIR and IIR filters are essential tools in digital signal processing, each with its own set of advantages and appropriate use cases. The choice between FIR and IIR filters depends on the specific requirements of the application, including considerations of phase linearity, computational efficiency, stability, and design complexity.

多滤波系统设计类型(Cascade)：

Audio filters are essential tools in audio processing that modify the frequency content of an audio signal. They are used to shape the sound by attenuating(使减弱) or amplifying specific frequency ranges. Here are some common types of audio filters:

#### Low-pass Filter (LPF)

- Allows frequencies below a certain cutoff frequency to pass through while attenuating frequencies above it.
- Useful for removing high-frequency noise or creating a smoother, warmer sound.
- Commonly used in subwoofer systems to allow only bass frequencies to pass through.

---

- f1: Cutoff frequency below which frequencies are passed through.
- No f2f2 as only one boundary is needed.

### High-pass Filter (HPF)

- Allows frequencies above a certain cutoff frequency to pass through while attenuating frequencies below it.
- Useful for removing low-frequency rumble or unwanted bass from a signal.
- Helps clarify vocals and instruments by removing low-end muddiness(浑).

---

- f1: Cutoff frequency above which frequencies are passed through.
- No f2f2 as only one boundary is needed.

### Band-pass Filter (BPF)

- Allows a specific range of frequencies, known as the passband, to pass through while attenuating frequencies outside this range.
- Useful for isolating specific frequency components or removing unwanted frequencies from a signal.
- Commonly used in equalizers and audio effects processors.

---

- f1: Lower cutoff frequency of the band-pass range.
- f2: Upper cutoff frequency of the band-pass range.

The filter allows frequencies between f1f1 and f2f2 to pass through, attenuating frequencies outside this range.

### Band-stop Filter (BSF) or Notch Filter

- Attenuates frequencies within a specific range, known as the stopband, while allowing frequencies outside this range to pass through.
- Useful for removing unwanted noise or interference from a signal.
- Commonly used to eliminate hum, buzz, or specific frequencies in audio recordings.

---

- f1: Lower cutoff frequency of the band-stop range.
- f2: Upper cutoff frequency of the band-stop range.

The filter attenuates frequencies between f1f1 and f2f2, allowing frequencies outside this range to pass through.

### Shelving Filters

- Attenuate or boost frequencies above or below a specified cutoff frequency.
- Shelf filters are categorized as low-shelf (LSF) or high-shelf (HSF) depending on whether they affect frequencies below or above the cutoff frequency.
- Used for tonal adjustments, such as boosting bass or enhancing treble.

### Peaking Filters

- Boost or cut frequencies around a specific center frequency.
- Allows precise control over the amplitude and bandwidth of the affected frequencies.
- Used for fine-tuning the tonal balance of audio signals or targeting specific problem frequencies.

### All-pass Filter

- Passes all frequencies without altering their amplitude but may change their phase relationship.
- Useful for phase manipulation and creating audio effects like phasing or flanging.

### Low Shelf Filter

- Boosts or attenuates frequencies below the cutoff frequency.
- Frequencies above the cutoff remain unchanged.
- Typically used for adjusting bass or adding warmth to audio signals.

### High Shelf Filter

- Boosts or attenuates frequencies above the cutoff frequency.
- Frequencies below the cutoff remain unchanged.
- Typically used for adjusting treble or adding brightness to audio signals.

### Application of Filters

- __Audio Production__: Filters are used in mixing and mastering to sculpt the frequency response of individual tracks and shape the overall sound of a recording.
- __Live Sound__: Filters are employed to control feedback, eliminate unwanted noise, and optimize the audio for different acoustic environments.
- __Consumer Audio__: Filters are integrated into audio playback systems, equalizers, and audio effects units to customize the listening experience according to user preferences.

Understanding the characteristics and applications of different filter types is crucial for achieving desired audio outcomes in various contexts.

#### 设计滤波器 BiQuadDesigner

[In here to found filter graph, BiQuadDesigner](https://arachnoid.com/BiQuadDesigner/index.html)

Parmetrs:

- Sample Frequency (Sampling Rate)：The sample frequency, or sampling rate, is the number of samples of audio carried per second, measured in hertz (Hz).
  - Common Values: Typical sampling rates include 44.1 kHz (CD quality), 48 kHz (professional audio), 96 kHz, and 192 kHz.
  - Importance: Determines the frequency range that can be accurately represented. According to the Nyquist theorem, the maximum frequency that can be accurately sampled is half of the sampling rate (e.g., a 44.1 kHz sampling rate can accurately represent frequencies up to 22.05 kHz).
- Center Frequency: The center frequency is the specific frequency around which a parametric equalizer's band is applied.
  - Determines the midpoint of the frequency band that will be boosted or cut.
  - In a parametric equalizer, users can select the center frequency to target specific parts of the audio spectrum (e.g., 1 kHz, 5 kHz).
- Gain (dB)
- Q Factor (Quality Factor): The Q factor, or Quality factor, describes the bandwidth of the frequency band affected by the filter relative to its center frequency.
  - High Q Factor: A high Q factor means a narrow bandwidth, affecting a small range of frequencies around the center frequency. Useful for making precise adjustments.
  - Low Q Factor: A low Q factor means a wide bandwidth, affecting a broad range of frequencies around the center frequency. Useful for more general tonal shaping.
  - Formula: Q is often calculated as the center frequency divided by the bandwidth (Q = f0 / BW), where f0 is the center frequency and BW is the bandwidth.
- S : Shelving Filters

How to calculate Q factor:

1. Determine the Bandwidth (BW)
  For each center frequency f0​, estimate the bandwidth using the adjacent center frequencies.  
  For example, for a given f0​, the approximate bandwidth can be the difference between the adjacent center frequencies:$BW≈f_{i+1}−f_{i−1}$.

2. Calculate Q Factor:
    Use the formula $Q=f_{0}/{BW}$​​.

Example: $31.5 63.0 125.0 250.0 500.0 1000 2000 4000 8000 16000$

For center frquency $f_0​=125Hz$

- Adjacent frequencies: $f_1=63Hz$ and $f_2=250Hz$.
- Bandwidth $BW=f_2−f_1=250Hz − 63Hz = 187Hz$.
- Q factor $Q=f_0/BW=125/187≈0.67$

Given that we are often working with center frequencies in a geometric series, the bandwidth for octave bands is typically about 1.414 times the center frequency (since $2^{1/2}≈1.41$ for octave spacing). Therefore, a rough estimation of the Q factor across all bands could be generalized as:

$Q≈f_0/(f_{i+1}−f-{i−1})$

In many standard equalizer designs, this value of $Q≈0.67$ is typical for octave band equalizers.

#### BiQuadDesigner 滤波器的应用

Peaking Filters:

```java
    /**
     * B≈2×fc Q=fc/B
     */
var qFactors = doubleArrayOf(
        0.67, 0.67, 0.67, 0.67, 0.67, 0.67, 0.67, 0.67, 0.67, 0.67
    )
private val mCoefficientLeft: ArrayList<BiQuadraticFilter> = arrayListOf()
mCoefficientLeft.add(BiQuadraticFilter())
   mCoefficientLeft.forEachIndexed { index, filter ->
        filter.configure(
            BiQuadraticFilter.PEAK, Utils.kThirdOct[index],
            outputAudioFormat!!.sampleRate.toDouble(), qFactors[index], filter.gainDB
        )
        //  filter.reset()
    }
//-----split----
sampleBufferRealLeft.forEachIndexed { index, it ->
    var outY: Double = it
    outY = highPassFilterLeft.filter(outY)
    outY = lowPassFilterLeft.filter(outY)
    mCoefficientLeft.forEach { filter ->
        outY = filter.filter(outY)
    }
    sampleBufferRealLeft[index] = (if (outY > 1.0) 1.0 else if (outY < -1.0) -1.0 else outY)
}
```

BandPass Filters:

```java
mCoefficientLeftBandPass.forEachIndexed { index, biQuadraticFilter ->
     biQuadraticFilter.configure(
         BiQuadraticFilter.BANDPASS, Utils.kThirdOct[index],
         outputAudioFormat!!.sampleRate.toDouble(), 2.0, biQuadraticFilter.gainDB
     )
}
// --------
sampleBufferRealLeft.forEachIndexed { index, it ->
    var outY: Double = it
    var sum = 0.0
    mCoefficientLeftBandPass.forEach { filter ->
        sum += filter.gain_abs * filter.filter(
            outY
        )
    }
    outY = sum
}
```

直接级联形式（Direct Form I和Direct Form II）在高Q值时可能会引入更多__噪声__，可以尝试使用瞬态变换形式（Transposed Direct Form）或者级联双二次结构（Cascade of Biquads），这些结构通常更稳定。

- 瞬态变换形式

```java
public class BiQuadFilter {
// ...
  private double w1, w2;

public void configure(){
    w1 = w2 = 0;
}

public double filter(double input) {
     double w0 = input - a1 * w1 - a2 * w2;
     double output = b0 * w0 + b1 * w1 + b2 * w2;
     // 重点在这里
     w2 = w1;
     w1 = w0;
     return output;
}

```

- 级联双二次结构

在级联双二次结构中，使用多个双二次滤波器来分解和实现复杂的滤波响应。每个双二次滤波器可以有相同或不同的Q值，具体取决于需要实现的滤波器响应。 

通常保持中心频率  `f0` 和采样频率 `fs`​ 不变。通过调整每个双二次滤波器的 Q 值，可以精细控制滤波器的频率响应。这样做可以创建更陡峭的滤波器边界或更宽的带通区域。

```java
// 滤波器设计参数
double f0 = 1000;  // 中心频率，Hz
double[] Qs = {1, 2, 5}; // 不同的Q值
double fs = 44100; // 采样频率，Hz

// 创建级联滤波器
CascadeFilter cascadeFilter = new CascadeFilter();

// 添加双二次滤波器到级联中，可以根据需要添加更多的双二次滤波器
for (double Q : Qs) {
    cascadeFilter.addFilter(new BiQuadFilter(f0, Q, fs, "bandpass"));
}
```

- 零极点实现带通滤波器

#### 设计滤波器  butterWorth

Butterworth滤波器和双二次滤波器（BiQuadratic Filter）都是常用的数字滤波器，但它们在设计和应用上有一些显著的不同。

##### Butterworth滤波器

###### 特点

- 平坦的频率响应：Butterworth滤波器的一个显著特点是其在通带内具有非常平坦的频率响应。没有任何波动，这意味着所有通过的频率成分的幅度都几乎不变。
- 设计简单：可以通过标准的滤波器设计公式或使用现成的软件工具来设计Butterworth滤波器。
- 较慢的衰减：在通带和阻带之间的过渡区域，Butterworth滤波器的衰减相对较慢，这可能导致在某些应用中不足够锐利的滤波效果。

###### 应用

- 音频处理
- 信号处理中的基础滤波需求
- 需要平坦频率响应的应用

##### 双二次滤波器（BiQuadratic Filter）

###### 特点

1. __灵活性__：双二次滤波器是一种更灵活的滤波器设计方法，可以实现多种滤波响应类型，包括低通、高通、带通和带阻滤波器。
2. __设计复杂__：与Butterworth滤波器相比，双二次滤波器的设计和实现可能更为复杂，但它的参数可以更自由地调整以适应具体的滤波需求。
3. __高Q值设计__：可以实现高品质因数（Q值）的滤波器，适用于需要非常窄带或锐利过渡的场合。

###### 应用

- 需要特定滤波特性的场合
- 高品质因数的滤波需求
- 复杂信号处理

##### 比较

| 特点 | Butterworth滤波器 | 双二次滤波器 |
| ---- | ---------------- | ------------- |
| 频率响应 | 通带内非常平坦 | 可定制各种响应类型 |
| 设计复杂度 | 简单 | 较复杂 |
| 过渡带衰减 | 较慢 | 可根据设计调整 |
| 应用领域 | 一般音频处理，基础滤波 | 复杂信号处理，高Q值需求 |

##### 选择指南

1. __如果需要平坦的通带响应且设计简单__，Butterworth滤波器是一个合适的选择。
2. __如果需要特定的滤波响应，或者需要高Q值的滤波器__，双二次滤波器会更为适合。

总体而言，选择哪种滤波器主要取决于应用的具体需求、所需的频率响应特性和设计复杂度的要求。

### 分贝计算

- Decibels are a logarithmic unit used to describe ratios of power or intensity.
- In audio processing, dB is often used to represent gain (amplification) or attenuation (reduction) of signals.

The formula `FastMath.pow(10, gainDB / 40)` is used to convert a gain in decibels to a linear scale factor. This conversion is essential because __most digital audio processing operations require linear scale values rather than logarithmic dB values__.

Why / 40?

The calculation `FastMath.pow(10, gainDB / 40)` is used in the context of equalizers and filters, particularly for audio processing, when dealing with gains and losses that affect __both positive and negative__ decibel (dB) values.

- Power(功率) vs. Amplitude(振幅):
    For power, the relationship is power ratio $(linear)=10^{(dB/10)}$.
    For amplitude (voltage(电压) or current(电流)), the relationship is amplitude $ratio (linear)=10^{(dB/20)}$.

- Bipolar Signals:
    In some contexts, especially for bipolar signals (signals that swing between positive and negative values, like audio signals), the effective gain can be considered over a range that encompasses both positive and negative swings, hence the use of `/ 40` instead of `/ 20`.

Typically, for converting `dB` gain to a linear scale factor for amplitude, you use:

$linear gain=10^{(dB/20)}$

This is because decibels for amplitude are calculated as:

$dB=20log_{⁡10}(amplitude ratio)$

Standard Conversion: `Math.pow(10, gainDB / 20)` converts dB to linear scale for amplitude adjustments.

Special Case: `Math.pow(10, gainDB / 40)` may be used in specific scenarios to achieve more subtle gain adjustments.
