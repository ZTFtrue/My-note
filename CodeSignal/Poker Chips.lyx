#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrartcl
\use_default_options true
\maintain_unincluded_children false
\language chinese-simplified
\language_package default
\inputencoding utf8-cjk
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\font_cjk bsmi
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
有一张有n个人的桌子. 每个人都应该有m个筹码，但由于一次意外每个人都得到了
\begin_inset Formula $c_{i}$
\end_inset

个筹码，我们的目标是以最少的步数恢复筹码的平衡, 并且只能与桌子上的相邻邻居进行交换，且一次只能交换一个筹码. 很明显
\begin_inset Formula $\sideset{m=\frac{1}{n}}{_{i-1}}\stackrel[i=1]{n}{\varSigma}$
\end_inset


\end_layout

\begin_layout Standard
现在，我们将两个人之间的盈余定义为流动，其中正流动意味着将筹码移至右侧，而负流动意味着得到一个筹码从左边. 这表示
\begin_inset Formula $f_{0}$
\end_inset

 来自最后一个人
\begin_inset Formula $c_{n-1}$
\end_inset

 给第一人
\begin_inset Formula $c_{0}$
\end_inset

，
\begin_inset Formula $f_{1}=f_{0}+c_{0}-m$
\end_inset

流表示从
\begin_inset Formula $c_{0}$
\end_inset

到
\begin_inset Formula $c_{1}$
\end_inset

(当前
\begin_inset Formula $c_{0}$
\end_inset

所有的加上从最后一个人得到的
\begin_inset Formula $f_{0}$
\end_inset

减去平均就是应得的)，
\begin_inset Formula $f_{2}:=f_{0}+c_{0}-m+c_{1}-m=f_{1}+c_{1}-m$
\end_inset

流表示从
\begin_inset Formula $c_{1}$
\end_inset

到
\begin_inset Formula $c_{2}$
\end_inset

等等. 以此类推,得出重要的信息是: 第一个人和后一个人之间传递了多少筹码数(流量), 最好的这个值是必须使总流量最小. 定义零索引流向量 
\begin_inset Formula $f$
\end_inset

是从人
\begin_inset Formula $(i-1)\mod n$
\end_inset

 到人
\begin_inset Formula $i$
\end_inset

的数量，我们能够定义一个计算流量成本的函数，该函数将用于优化
\begin_inset Formula $f_{0}$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula $g(f_{0}​;d)=\stackrel[i=1]{n}{\varSigma}∣f_{i-1}∣$
\end_inset

 
\begin_inset CommandInset href
LatexCommand href
name "参考1"
target "https://math.stackexchange.com/questions/342268/what-does-the-semicolon-mean-in-a-function-definition/722256"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
现在每个人
\begin_inset Formula $i$
\end_inset

 从左手得到
\begin_inset Formula $f_{i}$
\end_inset

个筹码 并且给右边
\begin_inset Formula $f_{(i-1)\mod n}$
\end_inset

 个筹码. 从
\begin_inset Formula $f_{i}$
\end_inset

的定义和 差向量的定义
\begin_inset Formula $d$
\end_inset

存在
\begin_inset Formula $d=m-c$
\end_inset

(why?)的关系
\end_layout

\begin_layout Standard
\begin_inset Formula $d_{i}=f_{i}-f_{(i+1)\mod n}\iff f_{(i+1)\mod n}=f_{i}-d_{i}$
\end_inset


\end_layout

\begin_layout Standard
将该式带入函数
\begin_inset Formula $g$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $g(f_{0};d)=|f_{0}|+|f_{1}|+\cdots+|f_{n-1}|=|f_{0}|+|f_{0}-d_{0}|+\cdots+|f_{n-1}-d_{n-1}|=|f_{0}|+|f_{0}-d_{0}|+|f_{0}-d_{0}-d_{1}|+\cdots+|f_{0}-\stackrel[i=0]{n-2}{\varSigma}d_{i}|$
\end_inset


\end_layout

\begin_layout Standard
非常有意思. 从这里我们已经知道如何最小化绝对值之和: 使用中值!
\end_layout

\begin_layout Standard
所以
\end_layout

\begin_layout Standard
\begin_inset Formula $f_{0}=median(0,d_{0},d_{0}+d_{1},d_{0}+d_{1}+d_{2},\cdots,d_{0}+\cdots+d_{n-2})$
\end_inset


\end_layout

\begin_layout Standard
现在将
\begin_inset Formula $f$
\end_inset

重新放到
\begin_inset Formula $g$
\end_inset

函数中可计算出最少的交换次数. 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> import numpy as np
\end_layout

\begin_layout Plain Layout

>>> np.array([1, 5, 9, 10, 5])
\end_layout

\begin_layout Plain Layout

array([ 1,  5,  9, 10,  5])
\end_layout

\begin_layout Plain Layout

>>> a=np.array([1, 5, 9, 10, 5])
\end_layout

\begin_layout Plain Layout

>>> a.mean() # 计算数组的平均数, 得出m
\end_layout

\begin_layout Plain Layout

6.0
\end_layout

\begin_layout Plain Layout

>>> a-a.mean() # 计算盈余
\end_layout

\begin_layout Plain Layout

array([-5., -1.,  3.,  4., -1.])
\end_layout

\begin_layout Plain Layout

>>> np.cumsum(a - a.mean()) # 向右移动相加
\end_layout

\begin_layout Plain Layout

array([-5., -6., -3.,  1.,  0.])
\end_layout

\begin_layout Plain Layout

>>> s=np.cumsum(a - a.mean())
\end_layout

\begin_layout Plain Layout

>>> np.median(s) # 求中值
\end_layout

\begin_layout Plain Layout

-3.0
\end_layout

\begin_layout Plain Layout

>>> s-np.median(s)
\end_layout

\begin_layout Plain Layout

array([-2., -3.,  0.,  4.,  3.])
\end_layout

\begin_layout Plain Layout

>>> np.abs(s - int(np.median(s)))
\end_layout

\begin_layout Plain Layout

array([2., 3., 0., 4., 3.])
\end_layout

\begin_layout Plain Layout

>>> np.abs(s - int(np.median(s))).sum()
\end_layout

\begin_layout Plain Layout

12.0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
mean 返回均值
\end_layout

\begin_layout Standard
cumsum 求和
\end_layout

\begin_layout Standard
median 中值
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

import numpy as np
\end_layout

\begin_layout Plain Layout

def pokerChips(chips):
\end_layout

\begin_layout Plain Layout

	a = np.array(chips)
\end_layout

\begin_layout Plain Layout

	s = np.cumsum(a - a.mean())
\end_layout

\begin_layout Plain Layout

	return np.abs(s - int(np.median(s))).sum()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Other:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename image/pokerchips.png
	lyxscale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
按照非整数线性规划用单纯形法或者对偶单纯法， 然后对结果剪枝， 单纯形法
\end_layout

\end_body
\end_document
