# Sizeof与Strlen的区别

| 比较 |sizeof|strlen|
|--|---|---|
|类别|操作符|函数|
|结果计算|sizeof有操作符的特性 ，如果计算类型则必须加()，如果是变量名可以不加. 大部分编译器，在编译的时候就把sizeof计算过了,返回类型或是变量的长度,所以sizeof(x)可以用来定义数组维数，并且计算静态的空间数组会返回全部数组的尺寸，但是\b不能返回动态地被分派了的数组或外部的数组的尺寸. | strlen计算一个结构类型或变量时返回实际的大小，要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小.
|参数|sizeof可以用类型做参数|strlen只能用char*做参数,且必须是以''\\0''结尾的|
|数组|数组做sizeof的参数不退化. |由于数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址. 所以，数组做strlen的参数就退化为指针了.
|函数参数|sizeof还可以用函数做参数. |
|结果类型|sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型. 该类型保证能容纳实现所建立的最大对象的字节大小.  |

> 代码示例

```c
char str[10]=\"012345\";
int a=strlen(str); //a=6;
int b=sizeof(str); //而b=10;
char str[sizeof(str)];//可以用来定义数组维数
```

## 对静态数组处理

strlen 计算字符串的长度，以结束符 0x00 为字符串结束

```c
char str[20]=\"0123456789\";
int a=strlen(str); //a=10;
```

sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变.

```c
int b=sizeof(str); //b=20;
```

### 对指针处理

 ss是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是长整型的，所以是4.

```c
 char* ss = \"012345\";
 sizeof(ss);//ss=4
```

其实就是获得了字符串的第一位'0' 所占的内存空间，是char类型的，占了1位

```c
 sizeof(*ss)==1;\nstrlen(ss)= 6; // 如果要获得这个字符串的长度，则一定要使用 strlen
```

> sizeof返回定义arr数组时，编译器为其分配的数组空间大小，不关心里面存了多少数据. sizeof的结果是在编译时便计算好的. strlen只关心存储的数据内容，不关心空间的大小和类型. strlen的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小

## C  以数组作为参数

```c
fun(char [2])
fun(char [])
// 都等价于 fun(char *)
```

在C++里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小  
如果想在函数内知道数组的大小， 需要这样做:
进入函数后用memcpy拷贝出来，长度由另一个形参传进去  

```c
fun(unsiged char *p1, int len)
{
    unsigned char* buf = new unsigned char[len+1];
    memcpy(buf, p1, len);
}
```

sizeof返回定义arr数组时，编译器为其分配的数组空间大小，不关心里面存了多少数据. sizeof的结果是在编译时便计算好的.
strlen只关心存储的数据内容，不关心空间的大小和类型. strlen的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小.
