# 大端和小端

## 定义

> Big-Endian和Little-Endian的定义如下:
>
>1. Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端.
>2. Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端.

举一个例子，比如数字`0x 12 34 56 78`在内存中的表示形式为:
1)大端模式:
低地址 -----------------> 高地址  
0x12  |  0x34  |  0x56  |  0x78  

2)小端模式:
低地址 ------------------> 高地址  
0x78  |  0x56  |  0x34  |  0x12  

3)下面是两个具体例子:

16bit宽的数0x1234在Little-endian模式(以及Big-endian模式)CPU内存中的存放方式(假设从地址0x4000开始存放)为:

| 内存地址 | 小端模式存放内容 | 大端模式存放内容 |
|----------|------------------|------------------|
| 0x4000   | 0x34             | 0x12             |
| 0x4001   | 0x12             | 0x34             |
32bit宽的数0x12345678在Little-endian模式以及Big-endian模式)CPU内存中的存放方式(假设从地址0x4000开始存放)为:

| 内存地址 | 小端模式存放内容 | 大端模式存放内容 |
|----------|------------------|------------------|
| 0x4000   | 0x78             | 0x12             |
| 0x4001   | 0x56             | 0x34             |
| 0x4002   | 0x34             | 0x56             |
| 0x4003   | 0x12             | 0x78             |

__小端模式 : 强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样.__  
__大端模式 : 符号位的判定固定为第一个字节，容易判断正负.__

一般操作系统都是小端，而通讯协议和Java是大端的.

## 如何判断机器的字节序

可以编写一个小的测试程序来判断机器的字节序:

```c
BOOL IsBigEndian()
{
    int a = 0x1234;
    char b =  *(char *)&a;  //通过将int强制类型转换成char单字节，通过判断   起始存储位置. 即等于 取b等于a的低地址部分
    if( b == 0x12)
    {
        return TRUE;
    }
    return FALSE;
```

联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写:

```c
BOOL IsBigEndian()
{
    union NUM
    {
        int a;
        char b;
    }num;
    num.a = 0x1234;
    if( num.b == 0x12 )
    {
        return TRUE;
    }
    return FALSE;
}
```

## 转换

对于字数据(16位):

```c
#define BigtoLittle16(A)   (( ((uint16)(A) & 0xff00) >> 8)    | \
(( (uint16)(A) & 0x00ff) << 8))
```

对于双字数据(32位):

```c
#define BigtoLittle32(A)  ((( (uint32)(A) & 0xff000000) >> 24) | \
(( (uint32)(A) & 0x00ff0000) >> 8)   | \
(( (uint32)(A) & 0x0000ff00) << 8)   | \
(( (uint32)(A) & 0x000000ff) << 24))
```

## Note

在一些编程中可能需要注意大端模式和小端模式
